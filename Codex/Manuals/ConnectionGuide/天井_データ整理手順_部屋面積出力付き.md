# 天井のデータ整理手順（部屋面積出力付き）

目的:
- 各部屋の上にある天井要素（モデル天井）を特定し、部屋名ごとに天井情報を整理・保存します。
- 部屋パラメータ「仕上表 CH」と天井高さ（標高）を照合、部屋の「天井仕上」と天井タイプ名の一致も確認します。
- 出力には部屋面積（m²）を必ず含めます。

前提:
- 単位は入力 mm/deg（内部 ft/rad）
- JSON-RPC クライアント: `Manuals/Scripts/send_revit_command_durable.py`
- MCPポート `<PORT>` は `agent_bootstrap` の `server.process.port` で確認

---

## 出力仕様（JSON/CSV）
- 共通キー（代表例）
  - `roomId`, `roomLabel`, `roomLevelName`, `roomAreaM2`
  - `ceilingExists`（bool）, `ceilingId`, `ceilingTypeId`, `ceilingTypeName`, `ceilingElevationMm`
  - `chMm`（仕上表 CH 値 mm）, `chEqualsElevation`（±1mm一致）
  - `finish`（部屋「天井仕上」）, `finishEqualsType`（部屋仕上とタイプ名の一致）
- CSV は BOM 付き UTF‑8 で保存（Excel互換）

---

## 手順概要
1) `agent_bootstrap`（任意）：ポート・既定単位・ビュー情報の取得
2) 部屋一覧の取得：`get_rooms`（部屋名・中心点・面積[m²] を取得）
3) 部屋パラメータ取得：`get_room_params`（レベル名, 仕上表CH, 天井仕上）
4) 天井一覧の取得：`get_ceilings`（typeId, typeName, levelName, elevationMm など）
5) 天井外周の取得：`get_ceiling_boundaries` の `boundaries[].points`（mm）
6) 割当判定：部屋中心点が同レベルの天井外周ポリゴン内に入るか（even‑odd法）
7) 照合：`chMm` と `ceilingElevationMm`、`finish` と `ceilingTypeName`
8) 保存：集約JSON/CSV（BOM）と、部屋名別JSON

---

## コマンド例（PowerShell）

準備
```powershell
# 省略可：環境の確認
python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command agent_bootstrap --output-file temp_mcp/agent_bootstrap.json
$projId = (Get-Content -Raw temp_mcp/agent_bootstrap.json | ConvertFrom-Json).result.project.documentGuid
New-Item -ItemType Directory -Path $projId -ErrorAction SilentlyContinue | Out-Null
$ROOMS_DIR = Join-Path $projId 'rooms_ceiling'; New-Item -ItemType Directory -Path $ROOMS_DIR -ErrorAction SilentlyContinue | Out-Null
```

1) 部屋一覧（面積・中心点付き）
```powershell
$pRooms = @{ _shape = @{ page = @{ limit = 20000 } } } | ConvertTo-Json -Compress
python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command get_rooms --params $pRooms --output-file temp_mcp/get_rooms_full.json
$rooms = (Get-Content -Raw temp_mcp/get_rooms_full.json | ConvertFrom-Json).result.rooms
```

2) 各部屋のパラメータ
```powershell
function Get-RoomMeta([int]$roomId){
  $rp = python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command get_room_params --params (@{ elementId=$roomId; skip=0; count=300 } | ConvertTo-Json -Compress) | ConvertFrom-Json
  $levelName=$null; $chMm=$null; $finish=$null
  foreach($pr in ($rp.result.parameters ?? $rp.result.result.parameters)){
    if($pr.name -eq 'レベル'){ $levelName = if([string]::IsNullOrEmpty([string]$pr.display)){ [string]$pr.value } else { [string]$pr.display } }
    elseif($pr.name -eq '仕上表 CH'){
      $chMm = if($pr.value -ne $null){ [double]$pr.value } elseif(-not [string]::IsNullOrWhiteSpace([string]$pr.display)){ ([regex]::Match([string]$pr.display,'(-?\d+(?:\.\d+)?)').Groups[1].Value) -as [double] } else { $null }
    }
    elseif($pr.name -eq '天井仕上'){ $finish = if([string]::IsNullOrEmpty([string]$pr.display)){ [string]$pr.value } else { [string]$pr.display } }
  }
  return @{ levelName=$levelName; chMm=$chMm; finish=$finish }
}
```

3) 天井一覧と外周
```powershell
$pCeil = @{ _filter = @{ modelOnly = $true; excludeImports = $true }; _shape = @{ page = @{ limit = 20000 } } } | ConvertTo-Json -Depth 6 -Compress
python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command get_ceilings --params $pCeil --output-file temp_mcp/get_ceilings_all.json
$ceils = (Get-Content -Raw temp_mcp/get_ceilings_all.json | ConvertFrom-Json)
$ceils = $ceils.result.ceilings ?? $ceils.result.result.ceilings

# レベル名 → 天井配列
$ceilByLevel = @{}
foreach($c in $ceils){ $lvl=$c.levelName; if(-not $ceilByLevel.ContainsKey($lvl)){ $ceilByLevel[$lvl]=@() }; $ceilByLevel[$lvl]+=$c }

# 天井外周キャッシュ
$ceilBounds = @{}
foreach($c in $ceils){
  $p = @{ elementId = [int]$c.elementId } | ConvertTo-Json -Compress
  $resp = python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command get_ceiling_boundaries --params $p | ConvertFrom-Json
  $bounds = $resp.result.boundaries ?? $resp.result.result.boundaries
  if($bounds){ $ceilBounds[[int]$c.elementId] = $bounds }
  Start-Sleep -Milliseconds 50
}
```

4) ポリゴン内点判定（even‑odd）
```powershell
function Test-PointInPolygon($pt, $poly){
  $inside=$false; $n=$poly.Count; if($n -lt 3){ return $false }; $j=$n-1
  for($i=0; $i -lt $n; $i++){
    $xi=[double]$poly[$i].x; $yi=[double]$poly[$i].y
    $xj=[double]$poly[$j].x; $yj=[double]$poly[$j].y
    $cond1=($yi -gt $pt.y); $cond2=($yj -gt $pt.y)
    if($cond1 -ne $cond2){ $xCross = ($xj-$xi) * ($pt.y-$yi) / ([double](($yj-$yi)+1e-9)) + $xi; if($pt.x -lt $xCross){ $inside = -not $inside } }
    $j=$i
  }
  return $inside
}
```

5) 突合・保存
```powershell
$rows=@(); $byRoom=@{}
foreach($r in $rooms){
  $rid=[int]$r.elementId; $label=[string]$r.name; $roomAreaM2=[double]$r.area
  $center=@{x=[double]$r.center.x; y=[double]$r.center.y}
  $meta = Get-RoomMeta -roomId $rid; $lvl=$meta.levelName; $chMm=$meta.chMm; $finish=$meta.finish

  $ceil=$null
  if(-not [string]::IsNullOrWhiteSpace($lvl) -and $ceilByLevel.ContainsKey($lvl)){
    foreach($c in $ceilByLevel[$lvl]){
      $b=$ceilBounds[[int]$c.elementId]; if(-not $b){ continue }
      $outer = $b | Where-Object { $_.role -eq 'outer' } | Select-Object -First 1; if(-not $outer){ $outer=$b[0] }
      if(Test-PointInPolygon -pt $center -poly $outer.points){ $ceil=$c; break }
    }
  }

  if($ceil){
    $elevMm=$ceil.elevationMm; $typeId=$ceil.typeId; $typeName=$ceil.typeName
    $chOK = ($chMm -ne $null -and $elevMm -ne $null) ? ([math]::Abs([double]$chMm - [double]$elevMm) -le 1.0) : $false
    $fnOK = (-not [string]::IsNullOrWhiteSpace($finish) -and -not [string]::IsNullOrWhiteSpace($typeName) -and $finish -eq $typeName)
    $row=[ordered]@{ roomId=$rid; roomLabel=$label; roomLevelName=$lvl; roomAreaM2=$roomAreaM2; chMm=$chMm; finish=$finish; ceilingExists=$true; ceilingId=[int]$ceil.elementId; ceilingTypeId=[int]$typeId; ceilingTypeName=[string]$typeName; ceilingElevationMm=[double]$elevMm; chEqualsElevation=$chOK; finishEqualsType=$fnOK }
  } else {
    $row=[ordered]@{ roomId=$rid; roomLabel=$label; roomLevelName=$lvl; roomAreaM2=$roomAreaM2; chMm=$chMm; finish=$finish; ceilingExists=$false; ceilingId=$null; ceilingTypeId=$null; ceilingTypeName=$null; ceilingElevationMm=$null; chEqualsElevation=$false; finishEqualsType=$false }
  }
  $rows += (New-Object psobject -Property $row)
  if(-not $byRoom.ContainsKey($label)){ $byRoom[$label]=@() }; $byRoom[$label]+=$row
}

# 集約JSON
$all=[ordered]@{ ok=$true; projectId=$projId; total=$rows.Count; rooms=$rows }
$all | ConvertTo-Json -Depth 6 -Compress | Set-Content -Path (Join-Path $projId 'rooms_ceiling_audit.json') -NoNewline -Encoding UTF8

# 部屋別JSON
foreach($k in $byRoom.Keys){ $safe=($k -replace '[\\/:*?"<>|]', '_'); if([string]::IsNullOrWhiteSpace($safe)){ $safe='Unnamed' }; [ordered]@{ roomLabel=$k; items=$byRoom[$k] } | ConvertTo-Json -Depth 6 -Compress | Set-Content -Path (Join-Path $ROOMS_DIR ("${safe}_ceiling.json")) -NoNewline -Encoding UTF8 }

# CSV（BOM）
$csv = Join-Path $projId 'rooms_ceiling_audit.csv'
try { $rows | Select-Object roomId,roomLabel,roomLevelName,roomAreaM2,chMm,finish,ceilingExists,ceilingId,ceilingTypeId,ceilingTypeName,ceilingElevationMm,chEqualsElevation,finishEqualsType | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8BOM }
catch { $tmp=Join-Path $env:TEMP ([IO.Path]::GetRandomFileName()+'.csv'); $rows | Select-Object roomId,roomLabel,roomLevelName,roomAreaM2,chMm,finish,ceilingExists,ceilingId,ceilingTypeId,ceilingTypeName,ceilingElevationMm,chEqualsElevation,finishEqualsType | Export-Csv -Path $tmp -NoTypeInformation -Encoding utf8; $content=Get-Content -Raw $tmp; $bytes=[Text.Encoding]::UTF8.GetBytes($content); [byte[]]$bom=0xEF,0xBB,0xBF; $out=New-Object byte[] ($bom.Length+$bytes.Length); [Array]::Copy($bom,0,$out,0,$bom.Length); [Array]::Copy($bytes,0,$out,$bom.Length,$bytes.Length); [IO.File]::WriteAllBytes($csv,$out); Remove-Item $tmp -ErrorAction SilentlyContinue }
```

---

## 注意点
- 応答の入れ子: 一部の環境では `result.result.*` になることがあるため両方に対応
- 仕上表 CH: String の場合は display から数値抽出（mm想定）。許容差は ±1mm を既定
- 天井判定: 中心点法は「外周ポリゴンに穴」がある場合に取りこぼしがあり得る。要件次第で「部屋外周と天井外周の重なり面積>0」に拡張
- CSV は BOM 付き UTF‑8 で保存（Excel読込の文字化け回避）

---

## 拡張案
- 出力に `roomUniqueId`, `ceilingUniqueId` を追加
- 一致判定の厳格化（例: 仕上名の前後空白・全角/半角・記号の正規化）
- レベルやエリアでのフィルタリング（例: 指定レベルだけ処理）

---

## 拡張: CSV列の追加（uniqueId など）

部屋・天井の uniqueId を列として追加する例です。`get_rooms` および `get_ceilings` の応答に `uniqueId` が含まれる前提です。

追記ポイント（抜粋）
```powershell
# rows 生成時に uniqueId を付与
$roomUniqueId = [string]$r.uniqueId
$ceilingUniqueId = if($ceil){ [string]$ceil.uniqueId } else { $null }

$row=[ordered]@{
  roomId=$rid; roomUniqueId=$roomUniqueId; roomLabel=$label; roomLevelName=$lvl; roomAreaM2=$roomAreaM2;
  chMm=$chMm; finish=$finish; ceilingExists=($null -ne $ceil);
  ceilingId=($ceil?.elementId); ceilingUniqueId=$ceilingUniqueId; ceilingTypeId=($ceil?.typeId);
  ceilingTypeName=($ceil?.typeName); ceilingElevationMm=($ceil?.elevationMm);
  chEqualsElevation=$chOK; finishEqualsType=$fnOK
}

# CSV に列を追加
$rows | Select-Object \
  roomId,roomUniqueId,roomLabel,roomLevelName,roomAreaM2, \
  chMm,finish,ceilingExists, \
  ceilingId,ceilingUniqueId,ceilingTypeId,ceilingTypeName,ceilingElevationMm, \
  chEqualsElevation,finishEqualsType |
  Export-Csv -Path $csv -NoTypeInformation -Encoding utf8BOM
```

---

## 拡張: 中心点ではなく外周同士の重なり面積で判定

中心点（重心）では天井外周の「穴」や細分割された天井を取りこぼす可能性があります。より厳密に、部屋外周ポリゴンと天井外周ポリゴンの重なり面積がしきい値（>0）を超えるかで割当て判定する例です。

1) 部屋外周ポリゴンの取得（`get_room_boundary`）
```powershell
$rb = python -X utf8 Manuals/Scripts/send_revit_command_durable.py --port <PORT> --command get_room_boundary --params (@{ elementId=$rid } | ConvertTo-Json -Compress) | ConvertFrom-Json
$seg = $rb.result.loops[0].segments  # 代表ループ（外周）を想定。複数ループの場合は role 等の情報で外周を選択

# セグメント列 → 点列（単純直交形状想定の簡易復元）
function Build-PolygonFromSegments($segments){
  $pts = New-Object System.Collections.Generic.List[object]
  if(-not $segments -or $segments.Count -lt 3){ return $pts }
  # 連結の起点
  $pts.Add($segments[0].start)
  $last = $segments[0].end
  $used = New-Object System.Collections.Generic.HashSet[int]
  $used.Add(0) | Out-Null
  for($k=0; $k -lt 5000; $k++){
    $idx = -1
    for($i=1; $i -lt $segments.Count; $i++){
      if($used.Contains($i)){ continue }
      $s = $segments[$i]
      if(($s.start.x -eq $last.x -and $s.start.y -eq $last.y) -or ($s.end.x -eq $last.x -and $s.end.y -eq $last.y)){
        $idx = $i; break
      }
    }
    if($idx -lt 0){ break }
    $s = $segments[$idx]
    if($s.start.x -eq $last.x -and $s.start.y -eq $last.y){ $pts.Add($s.start); $last = $s.end; $pts.Add($last) }
    else { $pts.Add($s.end); $last = $s.start; $pts.Add($last) }
    $null = $used.Add($idx)
    # 終端が起点に戻ったら終了
    if([math]::Abs($last.x - $pts[0].x) -lt 1e-6 -and [math]::Abs($last.y - $pts[0].y) -lt 1e-6){ break }
  }
  # 重複や連続点の整理は必要に応じて実施
  return $pts
}
$roomPoly = Build-PolygonFromSegments $seg
```

2) 天井外周ポリゴン（既存）
```powershell
$bounds = $ceilBounds[[int]$ceil.elementId]
$outer = $bounds | Where-Object { $_.role -eq 'outer' } | Select-Object -First 1
if(-not $outer){ $outer = $bounds[0] }
$ceilPoly = $outer.points
```

3) 多角形のクリッピング（Sutherland–Hodgman; クリップ多角形は凸を想定）と面積計算（Shoelace）
```powershell
function Shoelace-Area($poly){
  if(-not $poly -or $poly.Count -lt 3){ return 0.0 }
  $sum = 0.0
  for($i=0; $i -lt $poly.Count; $i++){
    $j = ($i + 1) % $poly.Count
    $sum += ([double]$poly[$i].x * [double]$poly[$j].y) - ([double]$poly[$j].x * [double]$poly[$i].y)
  }
  return [math]::Abs($sum) * 0.5
}

function Clip-Polygon($subject, $clip){
  $output = $subject
  for($k=0; $k -lt $clip.Count; $k++){
    $input = $output; $output = @()
    if(-not $input -or $input.Count -eq 0){ break }
    $A = $clip[$k]; $B = $clip[($k+1) % $clip.Count]
    # クリップ辺の法線（左側を内側とする）
    function IsInside($P){ return (([double]($B.x - $A.x) * ([double]$P.y - [double]$A.y) - [double]($B.y - $A.y) * ([double]$P.x - [double]$A.x)) -ge 0) }
    function Intersect($P,$Q){
      $x1=[double]$P.x; $y1=[double]$P.y; $x2=[double]$Q.x; $y2=[double]$Q.y
      $x3=[double]$A.x; $y3=[double]$A.y; $x4=[double]$B.x; $y4=[double]$B.y
      $den = ($x1-$x2)*($y3-$y4) - ($y1-$y2)*($x3-$x4)
      if([math]::Abs($den) -lt 1e-9){ return $P } # 平行時は P を返す簡易実装
      $px = (($x1*$y2-$y1*$x2)*($x3-$x4) - ($x1*$y2-$y1*$x2)*($x3-$x4) + ($x1-$x2)*(($x3*$y4-$y3*$x4))) / $den
      $py = (($x1*$y2-$y1*$x2)*($y3-$y4) - ($y1-$y2)*(($x3*$y4-$y3*$x4))) / $den
      return @{x=$px; y=$py}
    }
    for($i=0; $i -lt $input.Count; $i++){
      $S = $input[$i]
      $E = $input[($i+1) % $input.Count]
      $Sin = IsInside $S; $Ein = IsInside $E
      if($Sin -and $Ein){ $output += ,$E }
      elseif($Sin -and -not $Ein){ $output += ,(Intersect $S $E) }
      elseif(-not $Sin -and $Ein){ $output += ,(Intersect $S $E); $output += ,$E }
      # 両方外側は何も出力しない
    }
  }
  ,$output
}

$intersection = Clip-Polygon $roomPoly $ceilPoly
$areaOverlap = Shoelace-Area $intersection
if($areaOverlap -gt 0.0){
  # 部屋と天井が重なっていると判定
}
```

注意: Sutherland–Hodgman は「クリップ多角形が凸」であることを仮定しています。一般的な矩形天井や矩形部屋では問題ありません。複雑な凹形状の場合は、セグメント交差に基づく汎用ポリゴンクリッピングや外部ライブラリの利用をご検討ください。

