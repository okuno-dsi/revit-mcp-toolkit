# 厳密判定ルーチン（テンプレ実装：ポリゴン重なり面積）

目的
- 部屋外周ポリゴンと、床/天井の分割領域ポリゴンの重なり面積を算出して「所属部屋」を厳密に判定するテンプレ実装です。
- PowerShell スクリプト断片として、そのまま貼り付けて利用できます。

方針
- クリッピング: Sutherland–Hodgman（クリップ側は凸を想定）。
- 面積: Shoelace 公式で多角形面積を算出（mm²）。
- フォールバック: 領域境界点が取得できない場合は、外周(BBox)や重心内点法へ切替。

関数群
```powershell
# 数値安定用（必要に応じて調整）
$EPS = 1e-9

function Poly-ShoelaceArea($poly){
  if(-not $poly -or $poly.Count -lt 3){ return 0.0 }
  $sum = 0.0
  for($i=0; $i -lt $poly.Count; $i++){
    $j = ($i + 1) % $poly.Count
    $sum += ([double]$poly[$i].x * [double]$poly[$j].y) - ([double]$poly[$j].x * [double]$poly[$i].y)
  }
  return [math]::Abs($sum) * 0.5
}

function Poly-ClipSuthHodg($subject, $clip){
  # クリップ多角形辺ごとの半平面クリッピング（左側を内側）
  $output = $subject
  if(-not $output -or $output.Count -eq 0){ return @() }
  for($k=0; $k -lt $clip.Count; $k++){
    $A = $clip[$k]; $B = $clip[($k+1)%$clip.Count]
    $input = $output; $output = @()
    if(-not $input -or $input.Count -eq 0){ break }
    function IsInside($P){
      return (([double]($B.x - $A.x) * ([double]$P.y - [double]$A.y) - [double]($B.y - $A.y) * ([double]$P.x - [double]$A.x)) -ge -$EPS)
    }
    function Intersect($P,$Q){
      $x1=[double]$P.x; $y1=[double]$P.y; $x2=[double]$Q.x; $y2=[double]$Q.y
      $x3=[double]$A.x; $y3=[double]$A.y; $x4=[double]$B.x; $y4=[double]$B.y
      $den = ($x1-$x2)*($y3-$y4) - ($y1-$y2)*($x3-$x4)
      if([math]::Abs($den) -lt $EPS){ return $P }
      $t = (($x1-$x3)*($y3-$y4) - ($y1-$y3)*($x3-$x4)) / $den
      return @{ x= $x1 + $t*($x2-$x1); y= $y1 + $t*($y2-$y1) }
    }
    for($i=0; $i -lt $input.Count; $i++){
      $S = $input[$i]
      $E = $input[($i+1)%$input.Count]
      $Sin = IsInside $S; $Ein = IsInside $E
      if($Sin -and $Ein){ $output += ,$E }
      elseif($Sin -and -not $Ein){ $output += ,(Intersect $S $E) }
      elseif(-not $Sin -and $Ein){ $output += ,(Intersect $S $E); $output += ,$E }
    }
  }
  ,$output
}

function Segments-ToPolygon($segments){
  # get_room_boundary の segments[] → 連結点列（外周）に復元（簡易版）
  $pts=@(); if(-not $segments -or $segments.Count -lt 3){ return ,$pts }
  $pts+= $segments[0].start; $last=$segments[0].end; $used=@{0=$true}
  for($k=0; $k -lt 5000; $k++){
    $idx=-1
    for($i=1; $i -lt $segments.Count; $i++){
      if($used.ContainsKey($i)){ continue }
      $s=$segments[$i]
      if(($s.start.x -eq $last.x -and $s.start.y -eq $last.y) -or ($s.end.x -eq $last.x -and $s.end.y -eq $last.y)){ $idx=$i; break }
    }
    if($idx -lt 0){ break }
    $s=$segments[$idx]
    if($s.start.x -eq $last.x -and $s.start.y -eq $last.y){ $last=$s.end; $pts+=$last } else { $last=$s.start; $pts+=$last }
    $used[$idx]=$true
    if([math]::Abs($last.x - $pts[0].x) -lt $EPS -and [math]::Abs($last.y - $pts[0].y) -lt $EPS){ break }
  }
  ,$pts
}

function Overlap-Area($roomPoly, $regionPoly){
  if(-not $roomPoly -or $roomPoly.Count -lt 3){ return 0.0 }
  if(-not $regionPoly -or $regionPoly.Count -lt 3){ return 0.0 }
  $clip = Poly-ClipSuthHodg $roomPoly $regionPoly
  if(-not $clip -or $clip.Count -lt 3){ return 0.0 }
  return Poly-ShoelaceArea $clip
}
```

使用例
```powershell
# 部屋外周
$rb = python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_room_boundary --params (@{ elementId=[int]$roomId } | ConvertTo-Json -Compress) | ConvertFrom-Json
$roomPoly = Segments-ToPolygon $rb.result.loops[0].segments

# 領域ポリゴン（A: 分割領域の境界が取れる場合）
$det = python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_face_region_detail --params (@{ elementId=[int]$elemId; faceIndex=$fi; regionIndex=$ri } | ConvertTo-Json -Compress) | ConvertFrom-Json
$regionPoly = $det.result.result.detail.boundaryLoops[0].points

# （B: 取れない場合の近似）
$cb = python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_ceiling_boundaries --params (@{ elementId=[int]$elemId } | ConvertTo-Json -Compress) | ConvertFrom-Json
$regionPoly = ($cb.result.boundaries ?? $cb.result.result.boundaries | Where-Object { $_.role -eq 'outer' } | Select-Object -First 1).points

# 重なり面積（mm²）
$overlapArea = Overlap-Area $roomPoly $regionPoly
if($overlapArea -gt 0.0){ 'BELONGS' } else { 'NO_OVERLAP' }
```

注意
- クリップ側凸の前提が成立しない場合や複雑な凹形／穴が多い場合は、汎用クリッピング（交点列挙）への差し替えを推奨します。
- 数値丸めの影響で極小の交差が出る場合はしきい値（例: > 1e-3 mm² など）を設けてください。
- 応答入れ子（result/result.result）は各呼び出しで両対応してください。




