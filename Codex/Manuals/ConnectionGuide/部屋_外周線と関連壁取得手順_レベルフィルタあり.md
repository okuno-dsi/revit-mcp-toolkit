# 部屋の外周線と関連壁の取得手順（レベルフィルタあり）

目的:
- 指定した部屋の外周線（区画線）を取得し、その外周線に平行で近接（≦500mm）し、かつ部屋の基準レベルと同じレベルにある壁のみを抽出します。
- 結果には壁タイプIDも含め、後続処理（集計・可視化）に活用します。

前提:
- 入出力の単位は mm/deg（サーバ側で内部単位へ変換）。
- JSON-RPC クライアントとして `Scripts/Reference/send_revit_command_durable.py` を使用。
- Revit MCP ポート `<PORT>` は `agent_bootstrap.server.process.port` で確認（例: 5210）。

---

## 手順概要
1) `agent_bootstrap` でプロジェクト/ビュー/コマンド情報を取得（任意）
2) 対象部屋の特定（ID取得）
3) 部屋のレベルID取得（基準レベル）
4) 部屋の外周線取得（`get_room_boundary`）
5) 同レベルの壁候補取得（`get_walls` + `_filter.includeLevelIds=[roomLevelId]`）
6) 幾何判定（`analyze_segments` で平行・距離・重複の確認）
7) JSON と CSV（BOM付UTF-8）で保存

---

## 詳細手順とコマンド例

以下の例では PowerShell を使用しています。`<PORT>` と `<ROOM_ID>` を適宜置き換えてください。部屋名からの特定例も併記します。

### 1) ブートストラップ（任意）
```powershell
python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command agent_bootstrap --output-file temp_mcp/agent_bootstrap.json
```

### 2) 対象部屋の特定（ID取得）
- 既に部屋IDが分かっている場合はスキップ。
- 部屋名で特定する簡易例（アクティブビュー内から「会議室A」を検索）:
```powershell
$viewId = (Get-Content -Raw temp_mcp/agent_bootstrap.json | ConvertFrom-Json).result.environment.activeViewId
$params = @{ viewId = [int]$viewId; _filter = @{ includeClasses = @('Room') }; _shape = @{ idsOnly = $true } } | ConvertTo-Json -Compress
python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_elements_in_view --params $params --output-file temp_mcp/rooms.json
$ids = (Get-Content -Raw temp_mcp/rooms.json | ConvertFrom-Json).result.elementIds
foreach($id in $ids){
  $p = @{ elementId = [int]$id } | ConvertTo-Json -Compress
  $r = python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_element_info --params $p | ConvertFrom-Json
  if($r.result.ok -and ($r.result.elements[0].typeName -like '*会議室A*')){ $ROOM_ID = [int]$id; break }
}
```

### 3) 部屋のレベルID取得（基準レベル）
- `get_room_params` でパラメータ「レベル」（parameterId=`-1006916`）の値（ElementId）を取得します。
```powershell
$p = @{ elementId = [int]$ROOM_ID; skip = 0; count = 50 } | ConvertTo-Json -Compress
python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_room_params --params $p --output-file temp_mcp/room_params.json
$rp = Get-Content -Raw temp_mcp/room_params.json | ConvertFrom-Json
$roomLevelId = ($rp.result.parameters | Where-Object { $_.name -eq 'レベル' }).value
```

### 4) 部屋の外周線取得
```powershell
$p = @{ elementId = [int]$ROOM_ID } | ConvertTo-Json -Compress
python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_room_boundary --params $p --output-file temp_mcp/room_boundary.json
```
- 取得結果: `result.loops[].segments[]` に `start{x,y,z}, end{x,y,z}`（mm）が入ります。

### 5) 壁候補の取得（レベルフィルタ適用）
- 部屋の基準レベルに属する壁のみを列挙し、タイプIDも含めます。
```powershell
$p = @{ _filter = @{ modelOnly = $true; excludeImports = $true; includeLevelIds = @([int]$roomLevelId) };
        _shape  = @{ page = @{ limit = 20000 } } } | ConvertTo-Json -Depth 6 -Compress
python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command get_walls --params $p --output-file temp_mcp/walls_level_filtered.json
```
- 取得結果: `result.walls[]` に `elementId, typeId, typeName, start{x,y,z}, end{x,y,z}, thickness, height` などが入ります（mm）。

### 6) 幾何判定（平行性・距離・重複）
- 各外周セグメント vs. 各壁の基準線について `analyze_segments`（mode=`2d`）を呼び、以下を満たす壁を抽出します。
  - 平行（`line.isParallel == true`）
  - 最近距離 `line.distanceBetweenParallelMm <= 500`（mm）
  - 外周線方向への投影重複長 > 0（注: `overlapExists` は「コリニア」判定時のみ真になるため、投影で重複長を自前計算）

PowerShell スニペット（最小例）:
```powershell
$boundary = (Get-Content -Raw temp_mcp/room_boundary.json | ConvertFrom-Json).result.loops[0].segments
$walls    = (Get-Content -Raw temp_mcp/walls_level_filtered.json | ConvertFrom-Json).result.walls
$angleTolDeg = 1.0; $maxDistMm = 500.0

function Dot($ax,$ay,$bx,$by){ $ax*$bx + $ay*$by }
function Len($ax,$ay){ [math]::Sqrt($ax*$ax + $ay*$ay) }

$results=@()
for($i=0; $i -lt $boundary.Count; $i++){
  $seg=$boundary[$i]; $a=$seg.start; $b=$seg.end
  $dx=[double]$b.x-[double]$a.x; $dy=[double]$b.y-[double]$a.y; $len=(Len $dx $dy)
  if($len -le 1e-6){ continue }
  $ux=$dx/$len; $uy=$dy/$len
  $matches=@()
  foreach($w in $walls){
    $params=@{ mode='2d'; seg1=@{a=@{x=[double]$a.x;y=[double]$a.y}; b=@{x=[double]$b.x;y=[double]$b.y}};
                     seg2=@{a=@{x=[double]$w.start.x;y=[double]$w.start.y}; b=@{x=[double]$w.end.x;y=[double]$w.end.y}};
                     tol=@{angleDeg=$angleTolDeg} } | ConvertTo-Json -Depth 6 -Compress
    $resp = python -X utf8 Scripts/Reference/send_revit_command_durable.py --port <PORT> --command analyze_segments --params $params | ConvertFrom-Json
    if(-not $resp.result.ok){ continue }
    $line = $resp.result.line
    if(-not $line.isParallel){ continue }
    $dist=[double]$line.distanceBetweenParallelMm
    if(($dist -gt $maxDistMm) -or ($null -eq $dist)){ continue }
    # 投影重複（外周線軸上）
    $s2a=(Dot ([double]$w.start.x-[double]$a.x) ([double]$w.start.y-[double]$a.y) $ux $uy)
    $s2b=(Dot ([double]$w.end.x  -[double]$a.x) ([double]$w.end.y  -[double]$a.y) $ux $uy)
    $wmin=[math]::Min($s2a,$s2b); $wmax=[math]::Max($s2a,$s2b)
    $omin=[math]::Max(0,$wmin);  $omax=[math]::Min($len,$wmax)
    $ov=$omax-$omin
    if($ov -le 0){ continue }
    $matches += [ordered]@{
      wallId=[int]$w.elementId; typeId=[int]$w.typeId; typeName=[string]$w.typeName;
      distanceMm=$dist; overlapOnAxisMm=[double]$ov;
      overlapStart=@{x=[double]$a.x + $ux*$omin; y=[double]$a.y + $uy*$omin};
      overlapEnd  =@{x=[double]$a.x + $ux*$omax; y=[double]$a.y + $uy*$omax};
      wallStart=$w.start; wallEnd=$w.end
    }
    Start-Sleep -Milliseconds 80  # サーバ推奨スロットリング
  }
  $results += [ordered]@{ segmentIndex=$i; start=$a; end=$b; matches=$matches }
}

$out=[ordered]@{ ok=$true; roomId=$ROOM_ID; roomLevelId=$roomLevelId; angleToleranceDeg=$angleTolDeg; maxDistanceThresholdMm=$maxDistMm; segments=$results }
$projId = (Get-Content -Raw temp_mcp/agent_bootstrap.json | ConvertFrom-Json).result.project.documentGuid
$dest = Join-Path -Path $projId -ChildPath 'room_boundary_wall_matches_level_filtered.json'
$out | ConvertTo-Json -Depth 8 -Compress | Set-Content -Path $dest -NoNewline -Encoding UTF8
```

### 7) CSV（BOM付UTF-8）での保存
```powershell
$projId = (Get-Content -Raw temp_mcp/agent_bootstrap.json | ConvertFrom-Json).result.project.documentGuid
$j = Get-Content -Raw (Join-Path $projId 'room_boundary_wall_matches_level_filtered.json') | ConvertFrom-Json
$rows=@()
foreach($seg in $j.segments){
  foreach($m in $seg.matches){
    $rows += [pscustomobject]@{
      SegmentIndex    = [int]$seg.segmentIndex
      SegStartX_mm    = [double]$seg.start.x
      SegStartY_mm    = [double]$seg.start.y
      SegEndX_mm      = [double]$seg.end.x
      SegEndY_mm      = [double]$seg.end.y
      WallId          = [int]$m.wallId
      WallTypeId      = [int]$m.typeId
      WallTypeName    = [string]$m.typeName
      DistanceMm      = [double]$m.distanceMm
      OverlapOnAxisMm = [double]$m.overlapOnAxisMm
      OverlapStartXmm = [double]$m.overlapStart.x
      OverlapStartYmm = [double]$m.overlapStart.y
      OverlapEndXmm   = [double]$m.overlapEnd.x
      OverlapEndYmm   = [double]$m.overlapEnd.y
    }
  }
}
$csv = Join-Path $projId 'room_boundary_wall_matches_level_filtered.csv'
try { $rows | Export-Csv -Path $csv -NoTypeInformation -Encoding utf8BOM }
catch {
  # 互換: BOM手動付与
  $tmp = Join-Path $env:TEMP ([IO.Path]::GetRandomFileName()+'.csv')
  $rows | Export-Csv -Path $tmp -NoTypeInformation -Encoding utf8
  $content = Get-Content -Raw $tmp; $bytes=[Text.Encoding]::UTF8.GetBytes($content); [byte[]]$bom=0xEF,0xBB,0xBF
  $out = New-Object byte[] ($bom.Length + $bytes.Length); [Array]::Copy($bom,0,$out,0,$bom.Length); [Array]::Copy($bytes,0,$out,$bom.Length,$bytes.Length)
  [IO.File]::WriteAllBytes($csv,$out); Remove-Item $tmp -ErrorAction SilentlyContinue
}
```

---

## 出力スキーマ（JSON 例）
```json
{
  "ok": true,
  "roomId": 60533298,
  "roomLevelId": 49173,
  "angleToleranceDeg": 1.0,
  "maxDistanceThresholdMm": 500.0,
  "segments": [
    {
      "segmentIndex": 0,
      "start": {"x": 15945.5, "y": 41740.0, "z": 0.0},
      "end":   {"x":  -240.0, "y": 41740.0, "z": 0.0},
      "matches": [
        {
          "wallId": 60525100,
          "typeId": 60524695,
          "typeName": "RC150 （練習用）",
          "distanceMm": 90.0,
          "overlapOnAxisMm": 1234.5,
          "overlapStart": {"x": 1000.0, "y": 41740.0},
          "overlapEnd":   {"x": 2234.5, "y": 41740.0},
          "wallStart": {"x": -330.0, "y": 41830.0, "z": -100.0},
          "wallEnd":   {"x": 40330.0, "y": 41830.0, "z": -100.0}
        }
      ]
    }
  ]
}
```

---

## 注意点・落とし穴
- レベルフィルタ: 必ず `includeLevelIds = [roomLevelId]` を指定して、他レベルの壁を除外してください。
- 外周線と壁が完全コリニアでない場合、`analyze_segments.line.overlapExists` は false のことがあるため、投影で重複長を計算しています。
- 角度許容は 1.0 deg 程度が実用的です。必要に応じて調整してください。
- 大規模プロジェクトでは API 呼び出しに待ち時間（80–150ms）を入れてスロットリングするのが安全です。
- 出力CSVは「UTF-8（BOM付き）」で保存しています（Excel互換）。

---

## 小ワザ
- `get_room_params` はパラメータ名フィルタが無い場合があるため、`skip`/`count` でページングしつつ `name == 'レベル'` を探すのが確実です。
- `get_walls` に `idsOnly` を使って軽量リストを先に取得し、詳細は必要な壁だけ `get_element_info` で補う方法も有効です。





